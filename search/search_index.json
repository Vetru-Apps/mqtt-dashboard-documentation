{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"MQTT Dashboard MqttDashboard is an Android application designed to allow you to interact, control and manage your MQTT-enabled devices, focusing on ease of use and on a beautiful User Interface. The focus of the app is not to create a MQTT network, and this goes to say that MqttDashboard is not a MQTT broker/server. You are supposed to provide it yourself, either by installing one on a local machine or by exploiting an online service. Discover more at the dedicated page . Through commonly-used or dedicated interface components - also called tiles here - you should be able to build yourself a great looking and extremely functional MQTT-enabled dashboard. In the next pages, we will try to guide you through setting up and running the application, getting comfortable with it and with its characteristics. We hope you'll enjoy the journey! Get yourself MqttDashboard from the Google PlayStore!","title":"The app"},{"location":"index.html#mqtt-dashboard","text":"MqttDashboard is an Android application designed to allow you to interact, control and manage your MQTT-enabled devices, focusing on ease of use and on a beautiful User Interface. The focus of the app is not to create a MQTT network, and this goes to say that MqttDashboard is not a MQTT broker/server. You are supposed to provide it yourself, either by installing one on a local machine or by exploiting an online service. Discover more at the dedicated page . Through commonly-used or dedicated interface components - also called tiles here - you should be able to build yourself a great looking and extremely functional MQTT-enabled dashboard. In the next pages, we will try to guide you through setting up and running the application, getting comfortable with it and with its characteristics. We hope you'll enjoy the journey! Get yourself MqttDashboard from the Google PlayStore!","title":"MQTT Dashboard"},{"location":"brokers.html","text":"Brokers An essential component of any MQTT network is the MQTT broker itself, namely a service running on a server, responsible for managing the connections with the client - such as MqttDashboard or any other client app, device or system, - dispatching messages on the correct topics, granting or rejecting access to unauthorized users. The first task you will need to perform in order to get your home MQTT network running is to set up a working broker. There are plenty of solutions out there, from self-hosted instances running on a local and low-power device (such as a Mosquitto broker on a RaspberryPi) to full-fledged online services (see for example CloudMqtt , Flespi , Amazon AWS and many others). We assume you already have a broker set up and running. If this were not the case, there are many great guides on the argument to get you started! Topics Topics are, in the MQTT world, similar to news channels. A device might want to subscribe to rooms/bedroom/temperature to stay updated on the thermometer readings, while publishing on rooms/bedroom/fan to turn on or off a fan when the room is warmer then a certain threshold. Both rooms/bedroom/temperature and rooms/bedroom/fan are topics, constructed in a hierarchical structure similar to computer folders; the main level ( room ) contains the children ones, such that an interested user could subscribe to a whole level using wildcards and listen for all messages regarding, for example, the 'channel' rooms/bedroom . Topics are used to 'mark' messages and to facilitate their distribution, in the same way you may sort your documents in a structured folder tree. In this way, clients can ask for only the messages they need, avoiding the need to go through and inspect all messages that are exchanged by the broker. The fan from the previous example will only see messages 'labelled' rooms/bedroom/temperature and ignore the others, only receiving updates on what it cares the most about. Wildcards MQTT foresees two main wildcards - i.e. special characters representing particular behaviors while subscribing (not publishing ). They allow the client to subscribe to a multitude of topics simultaneously without specifying their exact name; their operation differ slightly as you will see below. + - or single-level wildcard. It is used to subscribe to all topics matching the pattern, replacing only a level; it must be used between two topics separator ( / ). Some examples will clarify the concept. Take the subscription rooms/+/temperature ; it will cause the following results: rooms/bedroom/temperature will match rooms/kitchen/temperature will match rooms/bedroom/temperature/outside will not match home/rooms/bedroom/temperature will not match # , or multi-level wildcard, is employed instead to subscribe to topics matching one or more levels, and must be employed as last character of the subscription string. Again, one example will help. Take the subscription rooms/bedroom/temperature/# ; it will have these results: rooms/bedroom/temperature/outside will match rooms/bedroom/temperature/outside/windows will match rooms/bedroom/children/temperature/outside will not match Additionally, the special character $ is a wildcard used internally by MQTT brokers; we will not discuss it here, but you can have a look at the great MQTT guide by HiveMQ . MqttDashboard brokers In MqttDashboard, a broker is an object representing the connection parameters for a particular MQTT server. In order to send messages, subscribe to topics and in general to use the app at all, you will need to define a broker first. It will be the first action the app will suggest you to perform upon installation. Broker parameters The app offers you the following options to set up a connection with your broker. While some are strictly required, some are optional, thus you can leave them to their default value. Name (required): a user-friendly name identifying the broker to you; since this is not used while connecting to the broker, you can use any string that suits your needs. Address (required): defines the address of the broker you want to connect to; if not specified, tcp:// will be added at the beginning of the address and used as default protocol. All internet protocols ( tcp:// , ssl:// , ws:// , wss:// , mqtt:// , etc) are accepted. Port (required): the MQTT confection port. Remember that different protocols usually use different ports; it is common use to adopt 1883 in plain connections, 8883 for SSL/TLS. The port is either set by you or provided from the service provider at the moment of the creation of the broker instance. Client id (required): a unique string to identify the client. MqttDashboard generates a random ID, you can leave it untouched if you do not have specific needs. Warning The Client ID must be unique across all the clients connected to the broker. If tho devices share the same ID, the broker will try to grant a connection to both of them, resulting in an unstable behavior for both. Broker protection : specify username & password if the broker requires authentication. SSL connection : enable this option to use secured SSL/TLS connection; please remember to use the correct port number as well as to switch to ssl:// or wss:// . Read the dedicated page to learn more. Accept self-signed certificates : skips the verification of the broker's certificate ( any certificate) accepting it by default. This is not a secure way to proceed: better install your CA certificate in the trust chain via the dedicated Android Settings menu, or providing it to the app via the file picker interface. If your certificate has been issued by a trusted CA authority there should be no need to perform any of these actions. Skip hostname verification : skips the verification of the server's name against the one provided by the certificate. if a CA certificate is selected via the file picker, this option has no effect. If the broker requires a Client Certificate, select it via the designated file picker. Again, the need for a Client Cert will be either set by you or clearly communicated by the broker provider, so you should be aware of it; if you are not sure you need to provide a certificate, you probably don't. Warning CA Certificate and Client Certificate are copied to a private internal folder, due to stringent limitations posed by Android to the data access capabilities of the apps. If you update a certificate, it will be not updated in the app's private folder, and you will need to perform the certificate assignment again. Moreover, apps' private files are deleted upon uninstall; if you restore the app's backup and use a TLS certificate, remember to go again through the certificate picking process. QoS : selects the quality of service used when subscribing to the topics of the current broker. QoS for publishing is provided on a per-device basis (see tiles ). Use clean session : if using a persistent session, the broker will keep the information about the current connection, as subscribed topics, pending messages and so on, until the client reconnects; if a clean session is being used and the client disconnects for any reason, all information and messages that are queued will be deleted. KeepAlive interval : tells the broker how much time is allowed to pass without any message being exchanged. After this time has passed by (allowing some margin) without messages being exchanged, the broker will close the connection. Warning If you experience rare disconnections, it may be due to the keepAlive not being satisfied. The app automatically sends a PING message, but this could be messed up with either by Doze or by some proprietary OEM battery saver feature. To solve this issue you can try to: Whitelist the app (Android Settings > Apps > MqttDashboard > Battery > Do Not Optimize). Set the KeepAlive interval to 0. This will instruct the broker not to consider an inactive connection a lost one, thus effectively disabling this behavior. Do not connect at startup : tells the app not to connect to this broker when launched; you will need to manually start the connection from the overflow menu in the main screen (the three-dots icon). Use this option if the broker is rarely used or is not your main one and you do not want multiple connections in the background. With that being said, you should now be able to set up your first broker and move on to the next task: setting up tiles! Using Websockets The app automatically switches from TCP to Websocket connections depending on the protocol name you provide as part of the address. Default values are, if not set bey the user: tcp:// for plain connections, ssl:// if Use SSL connection is checked. If you wish to establish a websocket connection, provide ws:// as protocol name (e.g., ws://test.mosquitto.org will be the full address). If you instead want an encrypted websocket, use wss:// . Testing connection If you want to test or play around with different connection settings, there are a few open brokers available. The most commonly used is test.mosquitto.org , providing TCP and WS connections, with/without authentication and with/without encryption. Be aware that this is a publicly available broker, so any message you send will be visible by anybody. Moreover, testing TLS connections is not always feasible, as the server has problems with its CA certificate and Client certificate from time to time. Another one is broker.hivemq.com , available as plain TCP or WS. You can find a comprehensive list here . If you want to test an SSL connection (let's say with Amazon AWS), read the dedicated page .","title":"Brokers"},{"location":"brokers.html#brokers","text":"An essential component of any MQTT network is the MQTT broker itself, namely a service running on a server, responsible for managing the connections with the client - such as MqttDashboard or any other client app, device or system, - dispatching messages on the correct topics, granting or rejecting access to unauthorized users. The first task you will need to perform in order to get your home MQTT network running is to set up a working broker. There are plenty of solutions out there, from self-hosted instances running on a local and low-power device (such as a Mosquitto broker on a RaspberryPi) to full-fledged online services (see for example CloudMqtt , Flespi , Amazon AWS and many others). We assume you already have a broker set up and running. If this were not the case, there are many great guides on the argument to get you started!","title":"Brokers"},{"location":"brokers.html#topics","text":"Topics are, in the MQTT world, similar to news channels. A device might want to subscribe to rooms/bedroom/temperature to stay updated on the thermometer readings, while publishing on rooms/bedroom/fan to turn on or off a fan when the room is warmer then a certain threshold. Both rooms/bedroom/temperature and rooms/bedroom/fan are topics, constructed in a hierarchical structure similar to computer folders; the main level ( room ) contains the children ones, such that an interested user could subscribe to a whole level using wildcards and listen for all messages regarding, for example, the 'channel' rooms/bedroom . Topics are used to 'mark' messages and to facilitate their distribution, in the same way you may sort your documents in a structured folder tree. In this way, clients can ask for only the messages they need, avoiding the need to go through and inspect all messages that are exchanged by the broker. The fan from the previous example will only see messages 'labelled' rooms/bedroom/temperature and ignore the others, only receiving updates on what it cares the most about.","title":"Topics"},{"location":"brokers.html#wildcards","text":"MQTT foresees two main wildcards - i.e. special characters representing particular behaviors while subscribing (not publishing ). They allow the client to subscribe to a multitude of topics simultaneously without specifying their exact name; their operation differ slightly as you will see below. + - or single-level wildcard. It is used to subscribe to all topics matching the pattern, replacing only a level; it must be used between two topics separator ( / ). Some examples will clarify the concept. Take the subscription rooms/+/temperature ; it will cause the following results: rooms/bedroom/temperature will match rooms/kitchen/temperature will match rooms/bedroom/temperature/outside will not match home/rooms/bedroom/temperature will not match # , or multi-level wildcard, is employed instead to subscribe to topics matching one or more levels, and must be employed as last character of the subscription string. Again, one example will help. Take the subscription rooms/bedroom/temperature/# ; it will have these results: rooms/bedroom/temperature/outside will match rooms/bedroom/temperature/outside/windows will match rooms/bedroom/children/temperature/outside will not match Additionally, the special character $ is a wildcard used internally by MQTT brokers; we will not discuss it here, but you can have a look at the great MQTT guide by HiveMQ .","title":"Wildcards"},{"location":"brokers.html#mqttdashboard-brokers","text":"In MqttDashboard, a broker is an object representing the connection parameters for a particular MQTT server. In order to send messages, subscribe to topics and in general to use the app at all, you will need to define a broker first. It will be the first action the app will suggest you to perform upon installation.","title":"MqttDashboard brokers"},{"location":"brokers.html#broker-parameters","text":"The app offers you the following options to set up a connection with your broker. While some are strictly required, some are optional, thus you can leave them to their default value. Name (required): a user-friendly name identifying the broker to you; since this is not used while connecting to the broker, you can use any string that suits your needs. Address (required): defines the address of the broker you want to connect to; if not specified, tcp:// will be added at the beginning of the address and used as default protocol. All internet protocols ( tcp:// , ssl:// , ws:// , wss:// , mqtt:// , etc) are accepted. Port (required): the MQTT confection port. Remember that different protocols usually use different ports; it is common use to adopt 1883 in plain connections, 8883 for SSL/TLS. The port is either set by you or provided from the service provider at the moment of the creation of the broker instance. Client id (required): a unique string to identify the client. MqttDashboard generates a random ID, you can leave it untouched if you do not have specific needs. Warning The Client ID must be unique across all the clients connected to the broker. If tho devices share the same ID, the broker will try to grant a connection to both of them, resulting in an unstable behavior for both. Broker protection : specify username & password if the broker requires authentication. SSL connection : enable this option to use secured SSL/TLS connection; please remember to use the correct port number as well as to switch to ssl:// or wss:// . Read the dedicated page to learn more. Accept self-signed certificates : skips the verification of the broker's certificate ( any certificate) accepting it by default. This is not a secure way to proceed: better install your CA certificate in the trust chain via the dedicated Android Settings menu, or providing it to the app via the file picker interface. If your certificate has been issued by a trusted CA authority there should be no need to perform any of these actions. Skip hostname verification : skips the verification of the server's name against the one provided by the certificate. if a CA certificate is selected via the file picker, this option has no effect. If the broker requires a Client Certificate, select it via the designated file picker. Again, the need for a Client Cert will be either set by you or clearly communicated by the broker provider, so you should be aware of it; if you are not sure you need to provide a certificate, you probably don't. Warning CA Certificate and Client Certificate are copied to a private internal folder, due to stringent limitations posed by Android to the data access capabilities of the apps. If you update a certificate, it will be not updated in the app's private folder, and you will need to perform the certificate assignment again. Moreover, apps' private files are deleted upon uninstall; if you restore the app's backup and use a TLS certificate, remember to go again through the certificate picking process. QoS : selects the quality of service used when subscribing to the topics of the current broker. QoS for publishing is provided on a per-device basis (see tiles ). Use clean session : if using a persistent session, the broker will keep the information about the current connection, as subscribed topics, pending messages and so on, until the client reconnects; if a clean session is being used and the client disconnects for any reason, all information and messages that are queued will be deleted. KeepAlive interval : tells the broker how much time is allowed to pass without any message being exchanged. After this time has passed by (allowing some margin) without messages being exchanged, the broker will close the connection. Warning If you experience rare disconnections, it may be due to the keepAlive not being satisfied. The app automatically sends a PING message, but this could be messed up with either by Doze or by some proprietary OEM battery saver feature. To solve this issue you can try to: Whitelist the app (Android Settings > Apps > MqttDashboard > Battery > Do Not Optimize). Set the KeepAlive interval to 0. This will instruct the broker not to consider an inactive connection a lost one, thus effectively disabling this behavior. Do not connect at startup : tells the app not to connect to this broker when launched; you will need to manually start the connection from the overflow menu in the main screen (the three-dots icon). Use this option if the broker is rarely used or is not your main one and you do not want multiple connections in the background. With that being said, you should now be able to set up your first broker and move on to the next task: setting up tiles!","title":"Broker parameters"},{"location":"brokers.html#using-websockets","text":"The app automatically switches from TCP to Websocket connections depending on the protocol name you provide as part of the address. Default values are, if not set bey the user: tcp:// for plain connections, ssl:// if Use SSL connection is checked. If you wish to establish a websocket connection, provide ws:// as protocol name (e.g., ws://test.mosquitto.org will be the full address). If you instead want an encrypted websocket, use wss:// .","title":"Using Websockets"},{"location":"brokers.html#testing-connection","text":"If you want to test or play around with different connection settings, there are a few open brokers available. The most commonly used is test.mosquitto.org , providing TCP and WS connections, with/without authentication and with/without encryption. Be aware that this is a publicly available broker, so any message you send will be visible by anybody. Moreover, testing TLS connections is not always feasible, as the server has problems with its CA certificate and Client certificate from time to time. Another one is broker.hivemq.com , available as plain TCP or WS. You can find a comprehensive list here . If you want to test an SSL connection (let's say with Amazon AWS), read the dedicated page .","title":"Testing connection"},{"location":"changelog.html","text":"Changelog App Changelog 1.0.0 - June 5, 2021 We are releasing a pretty big update with version 1.0.0. While many of the upgrades may pass unnoticed as they are not UI-related, with v1.0.0-b65 we are pushing many stability and performance enhancements, tweaking the UI to make it feel more polished, releasing a new standard of tile - which will replace the old one -, providing new controls to the user to customize the app even more, and generally enhancing the functionalities. There is a compatibility warning with regards to v1.0.0-b65: The app is not compatible with old versions of Light and Thermostat compound tiles. You will have to manually upgrade. We are sorry for the inconvenience. Compatibility with old backup files will be granted until end August 2021 . Starting from September 2021, you will be able to restore older backups, but some information might be lost (e.g., icons, color, tile-specific options). Compatibility with older versions of the app (b64 and lower) while using JSON Export over MQTT will be granted until end August 2021 . Starting from September 2021, you will be able to share your tiles over MQTT, but some information might be lost (e.g., icons, color, tile-specific options). As such, please update the app on every device you intend to use and be sure to create a new database backup to ensure future compatibility. The new version brings lots of enhancements: Modified how we store information under the hood. This will allow to add cool stuff faster in the future. Redesigned 'Light' and 'Thermostat' tiles to not use a monolithic JSON entity, rather working on distinct topics. Added new options to already existing tiles (e.g. to progress and toggle tiles). Fixed connection stability issued. Added new options to the broker connection (option to not automatically connect, buttons to manually connect/disconnect, better TLS capabilities). General improvements and UI tweaks. Documentation Changelog 1.0.0 - May 31, 2021 First documentation commit.","title":"Changelog"},{"location":"changelog.html#changelog","text":"","title":"Changelog"},{"location":"changelog.html#app-changelog","text":"","title":"App Changelog"},{"location":"changelog.html#100-june-5-2021","text":"We are releasing a pretty big update with version 1.0.0. While many of the upgrades may pass unnoticed as they are not UI-related, with v1.0.0-b65 we are pushing many stability and performance enhancements, tweaking the UI to make it feel more polished, releasing a new standard of tile - which will replace the old one -, providing new controls to the user to customize the app even more, and generally enhancing the functionalities. There is a compatibility warning with regards to v1.0.0-b65: The app is not compatible with old versions of Light and Thermostat compound tiles. You will have to manually upgrade. We are sorry for the inconvenience. Compatibility with old backup files will be granted until end August 2021 . Starting from September 2021, you will be able to restore older backups, but some information might be lost (e.g., icons, color, tile-specific options). Compatibility with older versions of the app (b64 and lower) while using JSON Export over MQTT will be granted until end August 2021 . Starting from September 2021, you will be able to share your tiles over MQTT, but some information might be lost (e.g., icons, color, tile-specific options). As such, please update the app on every device you intend to use and be sure to create a new database backup to ensure future compatibility. The new version brings lots of enhancements: Modified how we store information under the hood. This will allow to add cool stuff faster in the future. Redesigned 'Light' and 'Thermostat' tiles to not use a monolithic JSON entity, rather working on distinct topics. Added new options to already existing tiles (e.g. to progress and toggle tiles). Fixed connection stability issued. Added new options to the broker connection (option to not automatically connect, buttons to manually connect/disconnect, better TLS capabilities). General improvements and UI tweaks.","title":"1.0.0 - June 5, 2021"},{"location":"changelog.html#documentation-changelog","text":"","title":"Documentation Changelog"},{"location":"changelog.html#100-may-31-2021","text":"First documentation commit.","title":"1.0.0 - May 31, 2021"},{"location":"contributing.html","text":"Contributing If you want to help the project grow, there are a few options waiting for you: Help found the developer via In-App purchases or donations - this financially help us, and every even small contribution is more than welcome! Translate the app's strings to your language With every update new phrases are introduced, so there is always work to be done! Open translations page Enhance the documentation When you become an expert in using the app, chances are you will note some shortages in this documentation. We encourage you to submit a pull request to the documentation repository when you feel you have something to add that could benefit others! Open repository Testing the documentation If you want to edit and test the documentation prior to committing, there are a few easy steps to get you started. Below are outlined the main steps, but feel free to follow the MkDocs documentation or Material for MkDocs . Install Python 3+. Python 2.7 will not work. Install pip : pip install --upgrade pip Install Material for MkDocs via pip install mkdocs-material Clone the repository locally to a folder on your system. Edit the files. Once finished, run in the base folder (the one containing mkdocs.yml ): mkdocs serve See the edited site at 127.0.0.1:8000","title":"Contributing"},{"location":"contributing.html#contributing","text":"If you want to help the project grow, there are a few options waiting for you: Help found the developer via In-App purchases or donations - this financially help us, and every even small contribution is more than welcome! Translate the app's strings to your language With every update new phrases are introduced, so there is always work to be done! Open translations page Enhance the documentation When you become an expert in using the app, chances are you will note some shortages in this documentation. We encourage you to submit a pull request to the documentation repository when you feel you have something to add that could benefit others! Open repository","title":"Contributing"},{"location":"contributing.html#testing-the-documentation","text":"If you want to edit and test the documentation prior to committing, there are a few easy steps to get you started. Below are outlined the main steps, but feel free to follow the MkDocs documentation or Material for MkDocs . Install Python 3+. Python 2.7 will not work. Install pip : pip install --upgrade pip Install Material for MkDocs via pip install mkdocs-material Clone the repository locally to a folder on your system. Edit the files. Once finished, run in the base folder (the one containing mkdocs.yml ): mkdocs serve See the edited site at 127.0.0.1:8000","title":"Testing the documentation"},{"location":"export-over-mqtt.html","text":"Exporting over MQTT Todo This section of the documentation is still to be written. Want to help out? Head over to the contributions page.","title":"Exporting the database over MQTT"},{"location":"export-over-mqtt.html#exporting-over-mqtt","text":"Todo This section of the documentation is still to be written. Want to help out? Head over to the contributions page.","title":"Exporting over MQTT"},{"location":"privacy.html","text":"Privacy Privacy disclaimer This app does not collect, store, share or sell any personal information about you, your actions inside the app or any detail about your connections options and details. Databases are stored locally and never exported, unless requested by the user; in this case the exported file is encrypted. Note that when exporting the database over MQTT, the security of the whole transation depends upon the security of your MQTT broker. The app makes use of Firebase Analytics to retrieve informations about crashes or bugs. Sensitive permissions MqttDashboard requests the following sensitive permissions in order to work properly: android.permission.INTERNET : internet communication is used to reach the MQTT broker. android.permission.ACCESS_NETWORK_STATE : used to determine whether to use public or private addresses.. android.permission.ACCESS_WIFI_STATE : used to determine if the phone is currently connected to a wifi network. android.permission.WRITE_EXTERNAL_STORAGE & android.permission.READ_EXTERNAL_STORAGE : used to backup and restore the database. android.permission.FOREGROUND_SERVICE : used to mantain the connection to the broker(s) in background. com.android.vending.BILLING : offers the user the ability to purchase additional services and to perform donations. android.permission.RECEIVE_BOOT_COMPLETED : enables the app to start the mqtt connections in background when the phone is turned on - if the option has been selected in settings.","title":"Privacy"},{"location":"privacy.html#privacy","text":"","title":"Privacy"},{"location":"privacy.html#privacy-disclaimer","text":"This app does not collect, store, share or sell any personal information about you, your actions inside the app or any detail about your connections options and details. Databases are stored locally and never exported, unless requested by the user; in this case the exported file is encrypted. Note that when exporting the database over MQTT, the security of the whole transation depends upon the security of your MQTT broker. The app makes use of Firebase Analytics to retrieve informations about crashes or bugs.","title":"Privacy disclaimer"},{"location":"privacy.html#sensitive-permissions","text":"MqttDashboard requests the following sensitive permissions in order to work properly: android.permission.INTERNET : internet communication is used to reach the MQTT broker. android.permission.ACCESS_NETWORK_STATE : used to determine whether to use public or private addresses.. android.permission.ACCESS_WIFI_STATE : used to determine if the phone is currently connected to a wifi network. android.permission.WRITE_EXTERNAL_STORAGE & android.permission.READ_EXTERNAL_STORAGE : used to backup and restore the database. android.permission.FOREGROUND_SERVICE : used to mantain the connection to the broker(s) in background. com.android.vending.BILLING : offers the user the ability to purchase additional services and to perform donations. android.permission.RECEIVE_BOOT_COMPLETED : enables the app to start the mqtt connections in background when the phone is turned on - if the option has been selected in settings.","title":"Sensitive permissions"},{"location":"tiles.html","text":"Tiles Tiles are in MqttDashboard the core objects that allow users to interact with their MQTT-enabled devices. A tile can be either a representation of a real world device or simply publish and subscribe on specific topics at the user input; in the first case we speak of compound tiles , while the latter are named standard tiles . Standard and compound tiles can coexist as part of the same broker and under the same group. The main difference between the two is the ability of the compound ones to group more than one input and output topics under the same interface. Hopefully with the following description we will be able to better convey the differences of the two. Tunables - what are they We define here tunables a set of settings impacting the operations of the tile; these could be related to the visual interface, to the tile's topics, or to how the tile will behave in response to input or outputs. Tunables are as such those settings strictly related to one particular type of tile; standard settings common to all tiles are simply names settings . You can use tunables to tweak and modify how a tile will look or work, limitedly to the options provided. Usually, standard tiles expose their most relevant settings via the new tile screen, so you won't have to look for them. On the contrary, compound tiles work with a predefined set of rules inferred from the base topic you provide during setup; in this case, use the tunables to customize them. Standard tiles Todo This section of the documentation could be enhanced. Want to help out? Head over to the contributions page. Settings Name : Defines the name of the tile that will be displayed on the home screen. Can be left blank. Subscribe topic (required): The topic to which the tile will subscribe and receive messages from. The wildcard described in the brokers page can be clearly used. Publish topic (required): the topic on which the tile will publish the payload. Info Subscribe or publish topic could not be available to certain tiles - output tiles (ex. Button) can only send messages, input tiles (ex. Chart) can only receive messages. Moreover be aware that tiles won't be updated if no message has been received; so if you plan to use different sub/pub topics the tile status could remain unmodified even though the message has been correctly sent. Payload is JSON : if enabled, the payload will be treated as JSON and parsed accordingly. You can specify both payload and timestamp paths. If it was not possible to parse the payload, the whole message will be considered as payload. If it was not possible to parse the timestamp, the current time will be used instead. The timestamp must be provided in the form of milliseconds from epoch (Unix time, milliseconds since Jan. 01, 1970 UTC). Tip You can find all the needed information at JsonPath Github page or at the dedicated working with JSON objects page. Customize output : enables the user to define a custom template for the outgoing message. The outbound value and the current timestamp (millis from epoch) are currently supported to be replaced prior to the message being sent. Placeholders can be inserted either by tapping on the proper buttons at top of the page or by typing in the desired placeholder. Available placeholder are: <<value>> for the tile value. <<timestamp>> for the current time in milliseconds from epoch. Tip This is the place to define a custom JSON message if your application needs a JSON-formatted payload. QoS : selects the quality of service used when sending the message. Defaults to 0 . Retain message : sets the retain message flag to let the broker know to keep the message available to future subscribers. Only works if the broker is set to have persistance. Tip To delete a persistent ( retained ) message, send an empty payload to its topic. UI settings : Show as shortcut : display the tile as a small, icon-only shortcut at the top of the screen for faster access. Compact layout : reduces the size of the tile to the minimum height to display its icon and name. Since no content is displayed, you will probably need to click on it to access its data. Paint card background : fill in the tile's background with the picked color. The background will be white (or black, if in dark theme) otherwise. Faq We are aware of users requiring more control over the tiles' appearance, specifically concerning their size. We are working to provide some customization options in these regards. Tunables There are no default tunables for standard tiles. Each tile type might expose custom tunables to customize its appearance or operations; check out the tile's documentation page to find out more! Available standard tiles The following standard tiles are currently available for you to pick: Buttons - sends a predefined payload upon user's click. Toggles - bistable tile that sends the payload corresponding to the opposite state (i.e. off when on and on when off ). Multi-selections - offers the user a list of messages to pick from. Text - displays incoming text and sends user-input strings. Progress - a progress bar showing the parsed incoming message in a predefined range. Date and time - shows a date - or time - picker. Line chart Color - displays a color picker for the user to choose from. Image - downloads and displays an image from the URL passed as payload. Compound tiles Compound tiles are more complex entity that aim to represent a physical device, allowing the user to manage different parameters at the same time and within the same interface. These tiles come with a predefined combination of state/command topics, but you have the possibility to override the settings and customize the behavior if you want to. Compound tiles group two or more parameters under the same UI control. As an example, a thermostat tile provides termperature , mode , setpoint and humidity as parameters. Parameters can be either state parameters, only providing input, command parameters providing an output, or both. For each parameter type, MqttDashboard generates a set of topics constructed on the base topic specified by the user, which are: <base topic>/<parameter name>/state for state or input parameters <base topic>/<parameter name>/command for command or output parameters Parameters with both state and output capabilities will generate two topics each. The state topic is used by the app to receive messages, thus is subscribed to; the command topic is the one used to publish the parameter upon user interaction. Let us first give a list of the properties common to every compound tile. Hang tight, an example will make things clear later on! Settings Name (required): user friendly name, the same as in standard tiles. Topic (required): the base topic upon which the tile will build all state and command topics. See Tunables or the following example for more info. QoS , Retain and UI settings as described above. Tunables Compound tiles come with a common set of tunables related to the parameters they act on. Use the tunables to customize state or command topics or the way the tile works. Each compound tile type might have additional tunables than the ones described here, specifically for its operations. Check out the tile-related page to find out more! For each state parameter, the available tunables are: <parameter>_state_topic : the state - or input - topic of that parameter. If empty, the default one will be used. <parameter>_json_path : the JsonPath string used to extract the payload from the incoming message. If the path is empty, the message is not a JSON Object or if the specified path is not found, the whole message will be interpreted as payload. For each command parameter, the available tunables are: <parameter>_command_topic : the command - or output - topic for the specified parameter. if empty, the default one will be used. <parameter>_retain : option to flag the outgoing message as retained. Defaults to false . In addition, for for parameters that provide both state and command capabilities, the following tunable is available: <parameter>_update_locally Available compound tiles The following compound tiles are currently available for you to pick: Light Thermostat Example Let's consider a thermostat compound tile, and suppose we set home/thermostat as the base topic . Thermostats expose to the user four parameters, namely: Setpoint : available as state and command topic. Temperature : available as state topic. Humidity : available as state topic. Mode : available as state and command topic. MqttDashboard will therefore generate state and command topics for each parameter following the previously described rule: state , or input, topics, to which it will subscribe: home/thermostat/setpoint/state home/thermostat/temperature/state home/thermostat/humidity/state home/thermostat/mode/state command , or output, topics, to which messages will be published: home/thermostat/setpoint/command home/thermostat/mode/command Upon user interaction, a message will be published to the respective command topic. Let's say the user changed the thermostat's setpoint from 20 to 22 : a message with 22 as payload will be sent to home/thermostat/setpoint/command . Let's now suppose the user changed the setpoint command topic to home/garage/furnace by acting on the tile's tunables. The tile still expects inputs from home/thermostat/setpoint/state to update its UI, while publishes to home/garage/furnace , thus no visual update is given when the user changes the setpoint. Since setpoint provides both state and command capabilities, the tile also exposes a tunable responsible for immediately updating the value on the state topic. When enabled, the app publishes on home/garage/furnace and locally sets the value of home/thermostat/setpoint/state to the outgoing value; in this way, the UI stays up-to-date and the user maintains separate input/output topics.","title":"Tiles"},{"location":"tiles.html#tiles","text":"Tiles are in MqttDashboard the core objects that allow users to interact with their MQTT-enabled devices. A tile can be either a representation of a real world device or simply publish and subscribe on specific topics at the user input; in the first case we speak of compound tiles , while the latter are named standard tiles . Standard and compound tiles can coexist as part of the same broker and under the same group. The main difference between the two is the ability of the compound ones to group more than one input and output topics under the same interface. Hopefully with the following description we will be able to better convey the differences of the two.","title":"Tiles"},{"location":"tiles.html#tunables-what-are-they","text":"We define here tunables a set of settings impacting the operations of the tile; these could be related to the visual interface, to the tile's topics, or to how the tile will behave in response to input or outputs. Tunables are as such those settings strictly related to one particular type of tile; standard settings common to all tiles are simply names settings . You can use tunables to tweak and modify how a tile will look or work, limitedly to the options provided. Usually, standard tiles expose their most relevant settings via the new tile screen, so you won't have to look for them. On the contrary, compound tiles work with a predefined set of rules inferred from the base topic you provide during setup; in this case, use the tunables to customize them.","title":"Tunables - what are they"},{"location":"tiles.html#standard-tiles","text":"Todo This section of the documentation could be enhanced. Want to help out? Head over to the contributions page.","title":"Standard tiles"},{"location":"tiles.html#settings","text":"Name : Defines the name of the tile that will be displayed on the home screen. Can be left blank. Subscribe topic (required): The topic to which the tile will subscribe and receive messages from. The wildcard described in the brokers page can be clearly used. Publish topic (required): the topic on which the tile will publish the payload. Info Subscribe or publish topic could not be available to certain tiles - output tiles (ex. Button) can only send messages, input tiles (ex. Chart) can only receive messages. Moreover be aware that tiles won't be updated if no message has been received; so if you plan to use different sub/pub topics the tile status could remain unmodified even though the message has been correctly sent. Payload is JSON : if enabled, the payload will be treated as JSON and parsed accordingly. You can specify both payload and timestamp paths. If it was not possible to parse the payload, the whole message will be considered as payload. If it was not possible to parse the timestamp, the current time will be used instead. The timestamp must be provided in the form of milliseconds from epoch (Unix time, milliseconds since Jan. 01, 1970 UTC). Tip You can find all the needed information at JsonPath Github page or at the dedicated working with JSON objects page. Customize output : enables the user to define a custom template for the outgoing message. The outbound value and the current timestamp (millis from epoch) are currently supported to be replaced prior to the message being sent. Placeholders can be inserted either by tapping on the proper buttons at top of the page or by typing in the desired placeholder. Available placeholder are: <<value>> for the tile value. <<timestamp>> for the current time in milliseconds from epoch. Tip This is the place to define a custom JSON message if your application needs a JSON-formatted payload. QoS : selects the quality of service used when sending the message. Defaults to 0 . Retain message : sets the retain message flag to let the broker know to keep the message available to future subscribers. Only works if the broker is set to have persistance. Tip To delete a persistent ( retained ) message, send an empty payload to its topic. UI settings : Show as shortcut : display the tile as a small, icon-only shortcut at the top of the screen for faster access. Compact layout : reduces the size of the tile to the minimum height to display its icon and name. Since no content is displayed, you will probably need to click on it to access its data. Paint card background : fill in the tile's background with the picked color. The background will be white (or black, if in dark theme) otherwise. Faq We are aware of users requiring more control over the tiles' appearance, specifically concerning their size. We are working to provide some customization options in these regards.","title":"Settings"},{"location":"tiles.html#tunables","text":"There are no default tunables for standard tiles. Each tile type might expose custom tunables to customize its appearance or operations; check out the tile's documentation page to find out more!","title":"Tunables"},{"location":"tiles.html#available-standard-tiles","text":"The following standard tiles are currently available for you to pick: Buttons - sends a predefined payload upon user's click. Toggles - bistable tile that sends the payload corresponding to the opposite state (i.e. off when on and on when off ). Multi-selections - offers the user a list of messages to pick from. Text - displays incoming text and sends user-input strings. Progress - a progress bar showing the parsed incoming message in a predefined range. Date and time - shows a date - or time - picker. Line chart Color - displays a color picker for the user to choose from. Image - downloads and displays an image from the URL passed as payload.","title":"Available standard tiles"},{"location":"tiles.html#compound-tiles","text":"Compound tiles are more complex entity that aim to represent a physical device, allowing the user to manage different parameters at the same time and within the same interface. These tiles come with a predefined combination of state/command topics, but you have the possibility to override the settings and customize the behavior if you want to. Compound tiles group two or more parameters under the same UI control. As an example, a thermostat tile provides termperature , mode , setpoint and humidity as parameters. Parameters can be either state parameters, only providing input, command parameters providing an output, or both. For each parameter type, MqttDashboard generates a set of topics constructed on the base topic specified by the user, which are: <base topic>/<parameter name>/state for state or input parameters <base topic>/<parameter name>/command for command or output parameters Parameters with both state and output capabilities will generate two topics each. The state topic is used by the app to receive messages, thus is subscribed to; the command topic is the one used to publish the parameter upon user interaction. Let us first give a list of the properties common to every compound tile. Hang tight, an example will make things clear later on!","title":"Compound tiles"},{"location":"tiles.html#settings_1","text":"Name (required): user friendly name, the same as in standard tiles. Topic (required): the base topic upon which the tile will build all state and command topics. See Tunables or the following example for more info. QoS , Retain and UI settings as described above.","title":"Settings"},{"location":"tiles.html#tunables_1","text":"Compound tiles come with a common set of tunables related to the parameters they act on. Use the tunables to customize state or command topics or the way the tile works. Each compound tile type might have additional tunables than the ones described here, specifically for its operations. Check out the tile-related page to find out more! For each state parameter, the available tunables are: <parameter>_state_topic : the state - or input - topic of that parameter. If empty, the default one will be used. <parameter>_json_path : the JsonPath string used to extract the payload from the incoming message. If the path is empty, the message is not a JSON Object or if the specified path is not found, the whole message will be interpreted as payload. For each command parameter, the available tunables are: <parameter>_command_topic : the command - or output - topic for the specified parameter. if empty, the default one will be used. <parameter>_retain : option to flag the outgoing message as retained. Defaults to false . In addition, for for parameters that provide both state and command capabilities, the following tunable is available: <parameter>_update_locally","title":"Tunables"},{"location":"tiles.html#available-compound-tiles","text":"The following compound tiles are currently available for you to pick: Light Thermostat","title":"Available compound tiles"},{"location":"tiles.html#example","text":"Let's consider a thermostat compound tile, and suppose we set home/thermostat as the base topic . Thermostats expose to the user four parameters, namely: Setpoint : available as state and command topic. Temperature : available as state topic. Humidity : available as state topic. Mode : available as state and command topic. MqttDashboard will therefore generate state and command topics for each parameter following the previously described rule: state , or input, topics, to which it will subscribe: home/thermostat/setpoint/state home/thermostat/temperature/state home/thermostat/humidity/state home/thermostat/mode/state command , or output, topics, to which messages will be published: home/thermostat/setpoint/command home/thermostat/mode/command Upon user interaction, a message will be published to the respective command topic. Let's say the user changed the thermostat's setpoint from 20 to 22 : a message with 22 as payload will be sent to home/thermostat/setpoint/command . Let's now suppose the user changed the setpoint command topic to home/garage/furnace by acting on the tile's tunables. The tile still expects inputs from home/thermostat/setpoint/state to update its UI, while publishes to home/garage/furnace , thus no visual update is given when the user changes the setpoint. Since setpoint provides both state and command capabilities, the tile also exposes a tunable responsible for immediately updating the value on the state topic. When enabled, the app publishes on home/garage/furnace and locally sets the value of home/thermostat/setpoint/state to the outgoing value; in this way, the UI stays up-to-date and the user maintains separate input/output topics.","title":"Example"},{"location":"tls-encryption.html","text":"Encrypted connections The application supports encrypted connections to brokers which support TLS (SSL or WSS). The aim of this page is to clarify what you need to provide to the app, the type of expected input files and the available options. The discussion below further expands what stated in the brokers section. In short The app requires a CA certificate following the X509 standard, and a Client certificate in PKCS12. If you instead have a Client certificate and a Client private key in PEM format, you can build your PKCS12 from them. Encrypted, unauthenticated connections To establish a secure SSL connection not requiring authentication, follow these steps: Set ssl:// or wss:// as your address' protocol (depending on whether you need secure TCP or websocket). Enable Use SSL connection in the dedicated dialog. Depending on the CA certificate source, you may need to perform one or more of the following steps: Add your CA cert file as part of the Android Trust chain, via the dedicated menu in Settings > Security > Certificates. Provide your CA cert to the app for it to directly verify the server; this step is alternative to the previous. The Select Accept self-signed certificates . This option instructs the connection manager of the app to not verify the server. This may be dangerous in case of a man-in-the-middle attack. Use it at your own risk. That's it. Now try to connect. Example: Flespi Flespi provides an online MQTT broker free of charges with TLS encryption. To test it out, register and create a new account. Once you have your broker address, create a new broker instance in the app and paste it there. Be sure to set ssl:// as the protocol (or wss:// if you want a websocket). Use the correct port, i.e. 8883 , or 443 for the websocket. Check Use SSL connection as enable in the related dialog. That's it. You do not need to upload Flespi's CA certificate since it is already recognized by the Android built-in trust chain. Encrypted, authenticated connections To establish a secure SSL connection not requiring authentication, follow these steps: Follow the steps outlined by the Encrypted, unauthenticated connections section. If authentication takes place via a username/password combination, provide them as part of the broker setup. If instead authentication occurs via Client certificate, proceed as follows depending on your certificate type: PKCS12 Client certificate: select your file from the dedicated dialog; if protected by a password, provide the password as well in Certificate password . PEM Client certificate: PEM client certificates are not directly supported. You will need to convert them to the PKCS12 format. But worry not, this is not complicated. Read the section below for a step-by-step guide. Generating a PKCS12 certificate Using OpenSSL locally To convert your PEM Client certificate/key pair to PKCS12 use openssl from command line; chances are you already have it installed in your system. To perform the conversion, type openssl pkcs12 -export -in cert.pem -inkey key.pem -certfile cacert.pem -out cert.p12 and, when prompted to, provide a password, or just press enter to skip. The input-output files are: cert.pem : your PEM-format Client certificate key.pem : your PEM-format Client private key. cacert.pem : the Certification Authority PEM certificate, the same you provide to the app under the name of CA cert . cert.p12 : the newly generated PKCS12 certificate to be copied to the smartphone and used in the app. Using an Online service There may be online services offering certificate type conversions. If you choose to go this way, be sure to trust the website, as you would be uploading sensitive information. Example: Amazon AWS The app does support connecting to AWS. Below we will give a brief outline of the steps you need to perform to get MqttDashboard to successfully connect to AWS. In the AWS IoT Core console, look for your endpoint name, in the form of <identifier>.iot.<region>.amazonaws.com and note it somewhere. Now, under the Security menu, generate a new certificate with one click option. Download the following files: xxx.cert.pem xxx.private.key AmazonCA.pem Convert the xxx.cert.pem and xxx.private.key into a client.p12 following the steps described above. Upload the two files ( AmazonCA.pem and client.p12 ) to your smartphone. In the same Security screen, select your certificate and activate it. Then, link it to a valid policy ; if you do not have any, create one. A good starting point is: { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Action\": \"iot:Connect\", \"Resource\": \"*\" }, { \"Effect\": \"Allow\", \"Action\": \"iot:Publish\", \"Resource\": \"*\" }, { \"Effect\": \"Allow\", \"Action\": \"iot:Subscribe\", \"Resource\": \"*\" } ] } Open MqttDashboard on your phone. Create a new broker with settings: Address : ssl://<identifier>.iot.<region>.amazonaws.com . Port : 8883. Use SSL connection : true. Attention Only use 8883 as port. 443 requires additional configuration that this app does not perform. Under the SSL settings: CA cert : pick AmazonCA.pem . Client cert : pick client.p12 . Client password : type in the password if you set one. Done. Enjoy the app!","title":"Establishing TLS connection"},{"location":"tls-encryption.html#encrypted-connections","text":"The application supports encrypted connections to brokers which support TLS (SSL or WSS). The aim of this page is to clarify what you need to provide to the app, the type of expected input files and the available options. The discussion below further expands what stated in the brokers section. In short The app requires a CA certificate following the X509 standard, and a Client certificate in PKCS12. If you instead have a Client certificate and a Client private key in PEM format, you can build your PKCS12 from them.","title":"Encrypted connections"},{"location":"tls-encryption.html#encrypted-unauthenticated-connections","text":"To establish a secure SSL connection not requiring authentication, follow these steps: Set ssl:// or wss:// as your address' protocol (depending on whether you need secure TCP or websocket). Enable Use SSL connection in the dedicated dialog. Depending on the CA certificate source, you may need to perform one or more of the following steps: Add your CA cert file as part of the Android Trust chain, via the dedicated menu in Settings > Security > Certificates. Provide your CA cert to the app for it to directly verify the server; this step is alternative to the previous. The Select Accept self-signed certificates . This option instructs the connection manager of the app to not verify the server. This may be dangerous in case of a man-in-the-middle attack. Use it at your own risk. That's it. Now try to connect.","title":"Encrypted, unauthenticated connections"},{"location":"tls-encryption.html#example-flespi","text":"Flespi provides an online MQTT broker free of charges with TLS encryption. To test it out, register and create a new account. Once you have your broker address, create a new broker instance in the app and paste it there. Be sure to set ssl:// as the protocol (or wss:// if you want a websocket). Use the correct port, i.e. 8883 , or 443 for the websocket. Check Use SSL connection as enable in the related dialog. That's it. You do not need to upload Flespi's CA certificate since it is already recognized by the Android built-in trust chain.","title":"Example: Flespi"},{"location":"tls-encryption.html#encrypted-authenticated-connections","text":"To establish a secure SSL connection not requiring authentication, follow these steps: Follow the steps outlined by the Encrypted, unauthenticated connections section. If authentication takes place via a username/password combination, provide them as part of the broker setup. If instead authentication occurs via Client certificate, proceed as follows depending on your certificate type: PKCS12 Client certificate: select your file from the dedicated dialog; if protected by a password, provide the password as well in Certificate password . PEM Client certificate: PEM client certificates are not directly supported. You will need to convert them to the PKCS12 format. But worry not, this is not complicated. Read the section below for a step-by-step guide.","title":"Encrypted, authenticated connections"},{"location":"tls-encryption.html#generating-a-pkcs12-certificate","text":"","title":"Generating a PKCS12 certificate"},{"location":"tls-encryption.html#using-openssl-locally","text":"To convert your PEM Client certificate/key pair to PKCS12 use openssl from command line; chances are you already have it installed in your system. To perform the conversion, type openssl pkcs12 -export -in cert.pem -inkey key.pem -certfile cacert.pem -out cert.p12 and, when prompted to, provide a password, or just press enter to skip. The input-output files are: cert.pem : your PEM-format Client certificate key.pem : your PEM-format Client private key. cacert.pem : the Certification Authority PEM certificate, the same you provide to the app under the name of CA cert . cert.p12 : the newly generated PKCS12 certificate to be copied to the smartphone and used in the app.","title":"Using OpenSSL locally"},{"location":"tls-encryption.html#using-an-online-service","text":"There may be online services offering certificate type conversions. If you choose to go this way, be sure to trust the website, as you would be uploading sensitive information.","title":"Using an Online service"},{"location":"tls-encryption.html#example-amazon-aws","text":"The app does support connecting to AWS. Below we will give a brief outline of the steps you need to perform to get MqttDashboard to successfully connect to AWS. In the AWS IoT Core console, look for your endpoint name, in the form of <identifier>.iot.<region>.amazonaws.com and note it somewhere. Now, under the Security menu, generate a new certificate with one click option. Download the following files: xxx.cert.pem xxx.private.key AmazonCA.pem Convert the xxx.cert.pem and xxx.private.key into a client.p12 following the steps described above. Upload the two files ( AmazonCA.pem and client.p12 ) to your smartphone. In the same Security screen, select your certificate and activate it. Then, link it to a valid policy ; if you do not have any, create one. A good starting point is: { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Action\": \"iot:Connect\", \"Resource\": \"*\" }, { \"Effect\": \"Allow\", \"Action\": \"iot:Publish\", \"Resource\": \"*\" }, { \"Effect\": \"Allow\", \"Action\": \"iot:Subscribe\", \"Resource\": \"*\" } ] } Open MqttDashboard on your phone. Create a new broker with settings: Address : ssl://<identifier>.iot.<region>.amazonaws.com . Port : 8883. Use SSL connection : true. Attention Only use 8883 as port. 443 requires additional configuration that this app does not perform. Under the SSL settings: CA cert : pick AmazonCA.pem . Client cert : pick client.p12 . Client password : type in the password if you set one. Done. Enjoy the app!","title":"Example: Amazon AWS"},{"location":"working-with-json.html","text":"Working with JSON objects When sending a message to the app, you can either choose a plain text message or a JSON formatted message. JSON objects can contain lots of informations in a structure organized following the parent/child logic. A standard JSON object could look something like this: { \"settings\": { \"color\":\"#8E1159\", \"brightness\":57 } } In this case, settings is the parent object where the nested values brightness and color are contained. Standard tiles Input topics If you need to extract values from an incoming message, use the Payload is JSON option, and specify the path for the value (payload) and for the timestamp to be displayed (if provided). As an example, let the JSON object look like the following: { \"foo_data\": { \"foo_string\": \"string\", \"foo_int\": 20 }, \"my_payload\":{ \"payload\":\"something\", \"timestamp\":123456 } } If you were willing to pass \"something\" to the app, the path you need to provide is $.my_payload.payload , resulting in \"something\" being extracted. Similarly for the timestamp: $.my_payload.timestamp resulting in 123456 . If, instead, the JSON contained an array, such as: { \"my_array\": [\"first\",\"second\",\"third\"] } the path could be: $.my_array[1] resulting in second . These are only two easy examples of what is possible to achieve; please refer to the JsonPath Github page for more and exhaustive tips; you can also find a link to a useful Path Evaluator at the linked page to perform test on your own JSON objects. Output topics Payload formatting for outgoing messages is only supported via text-based editing. This means that if you are willing to send { \"foo_data\": { \"foo_string\": \"string\", \"foo_int\": 20 } } at the press of a button, you will have to check the Output formatting option, with {\"foo_data\": {\"foo_string\": \"string\", \"foo_int\": 20}} as the template. Value substitution via placeholders is supported. Two placeholders are currently supported, namely: <<value>> for the tile's output value. <<timestamp>> for a UNIX-timestamp (milliseconds from epoch) representing the time the message was sent. For example, if you wanted foo_string to contain the tile output value, your template would look like this: {\"foo_data\": {\"foo_string\": \"<<value>>\", \"foo_int\": 20}} . Compound tiles Todo This section of the documentation is still to be written. Want to help out? Head over to the contributions page.","title":"Working with JSON Objects"},{"location":"working-with-json.html#working-with-json-objects","text":"When sending a message to the app, you can either choose a plain text message or a JSON formatted message. JSON objects can contain lots of informations in a structure organized following the parent/child logic. A standard JSON object could look something like this: { \"settings\": { \"color\":\"#8E1159\", \"brightness\":57 } } In this case, settings is the parent object where the nested values brightness and color are contained.","title":"Working with JSON objects"},{"location":"working-with-json.html#standard-tiles","text":"","title":"Standard tiles"},{"location":"working-with-json.html#input-topics","text":"If you need to extract values from an incoming message, use the Payload is JSON option, and specify the path for the value (payload) and for the timestamp to be displayed (if provided). As an example, let the JSON object look like the following: { \"foo_data\": { \"foo_string\": \"string\", \"foo_int\": 20 }, \"my_payload\":{ \"payload\":\"something\", \"timestamp\":123456 } } If you were willing to pass \"something\" to the app, the path you need to provide is $.my_payload.payload , resulting in \"something\" being extracted. Similarly for the timestamp: $.my_payload.timestamp resulting in 123456 . If, instead, the JSON contained an array, such as: { \"my_array\": [\"first\",\"second\",\"third\"] } the path could be: $.my_array[1] resulting in second . These are only two easy examples of what is possible to achieve; please refer to the JsonPath Github page for more and exhaustive tips; you can also find a link to a useful Path Evaluator at the linked page to perform test on your own JSON objects.","title":"Input topics"},{"location":"working-with-json.html#output-topics","text":"Payload formatting for outgoing messages is only supported via text-based editing. This means that if you are willing to send { \"foo_data\": { \"foo_string\": \"string\", \"foo_int\": 20 } } at the press of a button, you will have to check the Output formatting option, with {\"foo_data\": {\"foo_string\": \"string\", \"foo_int\": 20}} as the template. Value substitution via placeholders is supported. Two placeholders are currently supported, namely: <<value>> for the tile's output value. <<timestamp>> for a UNIX-timestamp (milliseconds from epoch) representing the time the message was sent. For example, if you wanted foo_string to contain the tile output value, your template would look like this: {\"foo_data\": {\"foo_string\": \"<<value>>\", \"foo_int\": 20}} .","title":"Output topics"},{"location":"working-with-json.html#compound-tiles","text":"Todo This section of the documentation is still to be written. Want to help out? Head over to the contributions page.","title":"Compound tiles"},{"location":"tiles/button.html","text":"Button Sends a static, pre-saved message to the specified topic on user input. Since no input capabilities are provided, the command topic option is not available. Tunables None.","title":"Button"},{"location":"tiles/button.html#button","text":"Sends a static, pre-saved message to the specified topic on user input. Since no input capabilities are provided, the command topic option is not available.","title":"Button"},{"location":"tiles/button.html#tunables","text":"None.","title":"Tunables"},{"location":"tiles/color.html","text":"Color Prompts the user with a color selection dialog. Once picked, the outgoing message representing the color can be formatted as color integer, HEX or HSL, depending on the tile's setting. The tile background can be painted with the received color, if desired; if the incoming color is not a valid color value, the tile will be painted with its default color. Color formats This orange color can be represented as: #FF5A30 - as HEX. [255, 90, 48] - as RGB. [12, 0.81, 1.00] - as HSV. The output format you choose is up to you, depending on your application's needs. While a single format is supported as output, you can give as input to the tile any supported format; the tile will try to parse it in the following order: HEX - RGB - HSV . RGB is supported with or without alpha channel (i.e. #RRGGBB or #AARRGGBB ). Tunables None.","title":"Color"},{"location":"tiles/color.html#color","text":"Prompts the user with a color selection dialog. Once picked, the outgoing message representing the color can be formatted as color integer, HEX or HSL, depending on the tile's setting. The tile background can be painted with the received color, if desired; if the incoming color is not a valid color value, the tile will be painted with its default color.","title":"Color"},{"location":"tiles/color.html#color-formats","text":"This orange color can be represented as: #FF5A30 - as HEX. [255, 90, 48] - as RGB. [12, 0.81, 1.00] - as HSV. The output format you choose is up to you, depending on your application's needs. While a single format is supported as output, you can give as input to the tile any supported format; the tile will try to parse it in the following order: HEX - RGB - HSV . RGB is supported with or without alpha channel (i.e. #RRGGBB or #AARRGGBB ).","title":"Color formats"},{"location":"tiles/color.html#tunables","text":"None.","title":"Tunables"},{"location":"tiles/date-time.html","text":"Date and time Prompts the user with a selection dialog to send either a timestamp ora a date. The default time format is HH:mm , with the ours in 24h format. The default date format is dd/MM/yyyy . You can change the output format via the tile's tunables. Input messages are not parsed ( at least for now ) so changing the default format won't affect received payloads. Warning The tile will not parse incoming message, rather simply display them. If you send banana to your date tile, your date tile will read banana . Tunables ui_date_format : change the output format for a date tile. Default to dd/mm/yyyy . You can use placeholders to modify the format (see below). In case an unrecognized placeholder is found, the tile will switch back to the default. ui_time_format Available formatters Examples Let's suppose it is the 28th June, 2020, at 18:35 (6:35 PM for you folks with limited clocks). You could achieve the following results (and more!): dd/MM/yyyy : 28/06/2020 , the default one; dd - MMMM, yy : 28 - June, 20 ; DD;ww : 180;27 , i.e. the 180th day of the year and the 27th week of the year; hh:mm:ss a : 06:35:00 PM . Seconds are zero as the app does not provide you a way to pick them. dd yyyy G DD ww HH hh mm : 28 2020 AD 180 27 18 06 35 , namely the 28th of the month, year 2020 AD, 180th day, 27th week, at 18 (or 6 PM) and 35 minutes. Not sure why anybody should want to use this format tho. You can find a list of all the available placeholders at this page . Note that the same placeholders are available for both the date and time variants, however, not all will have effect. Formatting a date tile as dd/mm/yyyy HH:mm will result in 28/06/2020 00:00 . Since the tile's task is to pick a date , the time will be neglected. Formatting a time tile as dd/mm/yyyy HH:mm will result in 28/06/2020 18:35 . Since the tile's task is to pick a time , and there cannot be a 00/00/0000 date, the date will be set to the current one. Todo This section of the documentation could be enhanced. Here could be reported the table of patterns and placeholders available at the above link. Want to help out? Head over to the contributions page.","title":"Date and time"},{"location":"tiles/date-time.html#date-and-time","text":"Prompts the user with a selection dialog to send either a timestamp ora a date. The default time format is HH:mm , with the ours in 24h format. The default date format is dd/MM/yyyy . You can change the output format via the tile's tunables. Input messages are not parsed ( at least for now ) so changing the default format won't affect received payloads. Warning The tile will not parse incoming message, rather simply display them. If you send banana to your date tile, your date tile will read banana .","title":"Date and time"},{"location":"tiles/date-time.html#tunables","text":"ui_date_format : change the output format for a date tile. Default to dd/mm/yyyy . You can use placeholders to modify the format (see below). In case an unrecognized placeholder is found, the tile will switch back to the default. ui_time_format","title":"Tunables"},{"location":"tiles/date-time.html#available-formatters","text":"","title":"Available formatters"},{"location":"tiles/date-time.html#examples","text":"Let's suppose it is the 28th June, 2020, at 18:35 (6:35 PM for you folks with limited clocks). You could achieve the following results (and more!): dd/MM/yyyy : 28/06/2020 , the default one; dd - MMMM, yy : 28 - June, 20 ; DD;ww : 180;27 , i.e. the 180th day of the year and the 27th week of the year; hh:mm:ss a : 06:35:00 PM . Seconds are zero as the app does not provide you a way to pick them. dd yyyy G DD ww HH hh mm : 28 2020 AD 180 27 18 06 35 , namely the 28th of the month, year 2020 AD, 180th day, 27th week, at 18 (or 6 PM) and 35 minutes. Not sure why anybody should want to use this format tho. You can find a list of all the available placeholders at this page . Note that the same placeholders are available for both the date and time variants, however, not all will have effect. Formatting a date tile as dd/mm/yyyy HH:mm will result in 28/06/2020 00:00 . Since the tile's task is to pick a date , the time will be neglected. Formatting a time tile as dd/mm/yyyy HH:mm will result in 28/06/2020 18:35 . Since the tile's task is to pick a time , and there cannot be a 00/00/0000 date, the date will be set to the current one. Todo This section of the documentation could be enhanced. Here could be reported the table of patterns and placeholders available at the above link. Want to help out? Head over to the contributions page.","title":"Examples"},{"location":"tiles/image.html","text":"Image This tile loads and displays the image from the provided URL - sent over to the tile's subscribe topic. If no image could be found at the provided URL, no image is displayed. Image download behavior The image will be loaded from cache after the first download, unless the URL changes (i.e., a message is received on the subscribe topic) or the \" Automatically invalidate \" option is enabled. In the latter case the cached image will be considered invalid after the provided time period ( 10 seconds minimum) and reloaded on the next refresh. Tunables None.","title":"Image"},{"location":"tiles/image.html#image","text":"This tile loads and displays the image from the provided URL - sent over to the tile's subscribe topic. If no image could be found at the provided URL, no image is displayed.","title":"Image"},{"location":"tiles/image.html#image-download-behavior","text":"The image will be loaded from cache after the first download, unless the URL changes (i.e., a message is received on the subscribe topic) or the \" Automatically invalidate \" option is enabled. In the latter case the cached image will be considered invalid after the provided time period ( 10 seconds minimum) and reloaded on the next refresh.","title":"Image download behavior"},{"location":"tiles/image.html#tunables","text":"None.","title":"Tunables"},{"location":"tiles/light.html","text":"Light Compatibility Due to radical changes in the tile's behavior and data structure, new light tiles are not compatible with their old implementation. We are sorry for any inconvenience! The Light tile can manage appliances whose status can be on, off or dimmed, with a brightness level between 0 and 100. For both input and output purposes, the tile assumes the following conventions: color : to be in HEX format. brightness : an integer value ranging from 0 to 100 . Parameters state parameters: brightness - the light brightness state communicated by the device (the light). color - the light color state communicated by the device (the light). command parameters brightness - the light desired brightness state picked by the user. color - the light desired color state picked by the user. Tunables Refer to the tunables section of the tiles page for the list of generated tunables related to the two parameters. Lights expose moreover the following dedicated tunables: None.","title":"Light"},{"location":"tiles/light.html#light","text":"Compatibility Due to radical changes in the tile's behavior and data structure, new light tiles are not compatible with their old implementation. We are sorry for any inconvenience! The Light tile can manage appliances whose status can be on, off or dimmed, with a brightness level between 0 and 100. For both input and output purposes, the tile assumes the following conventions: color : to be in HEX format. brightness : an integer value ranging from 0 to 100 .","title":"Light"},{"location":"tiles/light.html#parameters","text":"state parameters: brightness - the light brightness state communicated by the device (the light). color - the light color state communicated by the device (the light). command parameters brightness - the light desired brightness state picked by the user. color - the light desired color state picked by the user.","title":"Parameters"},{"location":"tiles/light.html#tunables","text":"Refer to the tunables section of the tiles page for the list of generated tunables related to the two parameters. Lights expose moreover the following dedicated tunables: None.","title":"Tunables"},{"location":"tiles/line-chart.html","text":"Line chart Displays a linear chart given an input array, in the following format: `[1, 2, 3, 4, 5, 6]` The array is expected to be enclosed in squared brackets and with values separated by a simple comma. The input array must contain at least 2 values; if it contains more than 20 values the first N-20 will be cut to better display the chart. Points will be drawn evenly spaced in the x axis. Invalid input arrays won't display any chart. Faq The app does not allow to draw charts by creating arrays with single incoming values to avoid inconsistences in the displayed data due to unreliable connections with the broker. You are required to construct a valid array (e.g. in NodeRED) prior sending it to the app to be displayed. The array can obviously be extracted from a JSON payload. See working with JSON or tiles for details. Examples Some examples of valid or invalid messages are here reported: [1, 2, 3, 4, 5, 6] [a, 2, 3, 4, 5, 6] [1, 2, 3, 4, 5, 6 [1, 2 3, 4, 5; 6] {1, 2, 3, 4, 5, 6} Tunables None.","title":"Line chart"},{"location":"tiles/line-chart.html#line-chart","text":"Displays a linear chart given an input array, in the following format: `[1, 2, 3, 4, 5, 6]` The array is expected to be enclosed in squared brackets and with values separated by a simple comma. The input array must contain at least 2 values; if it contains more than 20 values the first N-20 will be cut to better display the chart. Points will be drawn evenly spaced in the x axis. Invalid input arrays won't display any chart. Faq The app does not allow to draw charts by creating arrays with single incoming values to avoid inconsistences in the displayed data due to unreliable connections with the broker. You are required to construct a valid array (e.g. in NodeRED) prior sending it to the app to be displayed. The array can obviously be extracted from a JSON payload. See working with JSON or tiles for details.","title":"Line chart"},{"location":"tiles/line-chart.html#examples","text":"Some examples of valid or invalid messages are here reported: [1, 2, 3, 4, 5, 6] [a, 2, 3, 4, 5, 6] [1, 2, 3, 4, 5, 6 [1, 2 3, 4, 5; 6] {1, 2, 3, 4, 5, 6}","title":"Examples"},{"location":"tiles/line-chart.html#tunables","text":"None.","title":"Tunables"},{"location":"tiles/multi-selection.html","text":"Multi-selection The multi-selection tile acts as a button, with the difference that more than one value can be saved during configuration to be later displayed to the user as choices. When clicked, the tile prompts the user to select a value from a pre-determined list of alias/payload pairs. A pair, as here intended, consists of an alias - a friendly name the user will read in the selection dialog - and a payload - the value that will be actually sent. You can chose whether or not to show the payload in the selection dialog. Similarly to the button, this tile does not accept inputs. Tunables None.","title":"Multi-selection"},{"location":"tiles/multi-selection.html#multi-selection","text":"The multi-selection tile acts as a button, with the difference that more than one value can be saved during configuration to be later displayed to the user as choices. When clicked, the tile prompts the user to select a value from a pre-determined list of alias/payload pairs. A pair, as here intended, consists of an alias - a friendly name the user will read in the selection dialog - and a payload - the value that will be actually sent. You can chose whether or not to show the payload in the selection dialog. Similarly to the button, this tile does not accept inputs.","title":"Multi-selection"},{"location":"tiles/multi-selection.html#tunables","text":"None.","title":"Tunables"},{"location":"tiles/progress.html","text":"Progress This tile displays and sends numeric values in a given interval. Behavior If min is unset, its value is considered to be 0 . If max is unset, its value is considered to be min+100 . If max is smaller than min , its value is considered to be min+100 . If the incoming message is smaller then min the value is considered to be min . If the incoming message is greater then max the value is considered to be max . If the incoming message is not an integer nor a float, the value is considered to be min . Tunables send_on_tracking : immediately sends the progress bar value while dragging onto it, instead of waiting for the tracking action to complete (i.e. you lifting your finger). Depending on how much you like dragging the progress bar back and forth, this option may result in many messages being sent.","title":"Progress"},{"location":"tiles/progress.html#progress","text":"This tile displays and sends numeric values in a given interval.","title":"Progress"},{"location":"tiles/progress.html#behavior","text":"If min is unset, its value is considered to be 0 . If max is unset, its value is considered to be min+100 . If max is smaller than min , its value is considered to be min+100 . If the incoming message is smaller then min the value is considered to be min . If the incoming message is greater then max the value is considered to be max . If the incoming message is not an integer nor a float, the value is considered to be min .","title":"Behavior"},{"location":"tiles/progress.html#tunables","text":"send_on_tracking : immediately sends the progress bar value while dragging onto it, instead of waiting for the tracking action to complete (i.e. you lifting your finger). Depending on how much you like dragging the progress bar back and forth, this option may result in many messages being sent.","title":"Tunables"},{"location":"tiles/text.html","text":"Text Shows and sends text strings. When clicked, prompts the user to input a string to be sent to the selected output topic, while displaying the last received message on the input topic. Warning If input and output topic are different, the tile won't be updated with the newly sent text, as tiles only get updated on incoming messages. A prefix and a postfix can be selected to be displayed with the received text. These values won't be sent. Tunables None.","title":"Text"},{"location":"tiles/text.html#text","text":"Shows and sends text strings. When clicked, prompts the user to input a string to be sent to the selected output topic, while displaying the last received message on the input topic. Warning If input and output topic are different, the tile won't be updated with the newly sent text, as tiles only get updated on incoming messages. A prefix and a postfix can be selected to be displayed with the received text. These values won't be sent.","title":"Text"},{"location":"tiles/text.html#tunables","text":"None.","title":"Tunables"},{"location":"tiles/thermostat.html","text":"Thermostat Compatibility Due to radical changes in the tile's behavior and data structure, new thermostat tiles are not compatible with their old implementation. We are sorry for any inconvenience! The Thermostat tile can manage thermostats and heaters/coolers accepting and setting temperature and working mode; moreover, it displays incoming temperature and humidity values from their dedicated state topics. Parameters state parameters: setpoint - thermostat desired temperature, as set by an external source. mode - thermostat mode. Currently supported modes are on , off , heat , eco , cool , auto . temperature - room temperature as sensed by an external sensor. humidity - room humidity as sensed by an external sensor. command parameters setpoint - thermostat desired temperature set by the user. mode - thermostat working mode set by the user. Faq Custom modes will be added in a future release. Tunables Refer to the tunables section of the tiles page for the list of generated tunables related to the four parameters. Thermostats expose moreover the following dedicated tunables: ui_min_setpoint : minimum allowed value of the setpoint UI seekbar. Defaults to 15 . ui_max_setpoint : maximum allowed value of the setpoint UI seekbar. Defaults to 30 . ui_temperature_unit : temperature unit to be applied to both the setpoint and the ambient reading. Defaults to \u00b0C .","title":"Thermostat"},{"location":"tiles/thermostat.html#thermostat","text":"Compatibility Due to radical changes in the tile's behavior and data structure, new thermostat tiles are not compatible with their old implementation. We are sorry for any inconvenience! The Thermostat tile can manage thermostats and heaters/coolers accepting and setting temperature and working mode; moreover, it displays incoming temperature and humidity values from their dedicated state topics.","title":"Thermostat"},{"location":"tiles/thermostat.html#parameters","text":"state parameters: setpoint - thermostat desired temperature, as set by an external source. mode - thermostat mode. Currently supported modes are on , off , heat , eco , cool , auto . temperature - room temperature as sensed by an external sensor. humidity - room humidity as sensed by an external sensor. command parameters setpoint - thermostat desired temperature set by the user. mode - thermostat working mode set by the user. Faq Custom modes will be added in a future release.","title":"Parameters"},{"location":"tiles/thermostat.html#tunables","text":"Refer to the tunables section of the tiles page for the list of generated tunables related to the four parameters. Thermostats expose moreover the following dedicated tunables: ui_min_setpoint : minimum allowed value of the setpoint UI seekbar. Defaults to 15 . ui_max_setpoint : maximum allowed value of the setpoint UI seekbar. Defaults to 30 . ui_temperature_unit : temperature unit to be applied to both the setpoint and the ambient reading. Defaults to \u00b0C .","title":"Tunables"},{"location":"tiles/toggle.html","text":"Toggle The toggle tile allows you to control devices that require two states to function, as for example an on-off switch, an open-close door, an active-inactive service and so on. Any toggle tile can work both as a sensor (i.e. only passively receiving a state) and as actuator. In the latter case, whenever the user presses the tile, the on payload will be sent if the current state is off and vice versa. If the state is not set or not recognized, the on state will be be sent by default. Tip You can override the default behavior when sending a payload from a unrecognized state via the dedicated tunable. Different icons and color can be set to be shown when the state is on or off . In the unknown state, the tile's icon and color will be used instead. Warning The state of the tile is determined by the value received on the state topic (input topic). If this topic is different from the command topic (output topic) the tile's state will not be updated when a new value is sent. This may lead to unwanted behavior. Tunables payload_default_off : overrides the default behavior and sends the off payload instead of the on one when the tile's state is unknown .","title":"Toggle"},{"location":"tiles/toggle.html#toggle","text":"The toggle tile allows you to control devices that require two states to function, as for example an on-off switch, an open-close door, an active-inactive service and so on. Any toggle tile can work both as a sensor (i.e. only passively receiving a state) and as actuator. In the latter case, whenever the user presses the tile, the on payload will be sent if the current state is off and vice versa. If the state is not set or not recognized, the on state will be be sent by default. Tip You can override the default behavior when sending a payload from a unrecognized state via the dedicated tunable. Different icons and color can be set to be shown when the state is on or off . In the unknown state, the tile's icon and color will be used instead. Warning The state of the tile is determined by the value received on the state topic (input topic). If this topic is different from the command topic (output topic) the tile's state will not be updated when a new value is sent. This may lead to unwanted behavior.","title":"Toggle"},{"location":"tiles/toggle.html#tunables","text":"payload_default_off : overrides the default behavior and sends the off payload instead of the on one when the tile's state is unknown .","title":"Tunables"}]}